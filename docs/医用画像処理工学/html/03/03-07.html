<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>周波数領域フィルタリングツール</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        h2 {
            color: #3498db;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            margin-top: 20px;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }
        .canvas-container {
            position: relative;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: auto;
            background-color: #f9f9f9;
        }
        .canvas-label {
            position: absolute;
            top: 5px;
            left: 5px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .control-panel {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }
        button {
            padding: 8px 12px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button.active {
            background-color: #2c3e50;
        }
        .action-button {
            background-color: #2ecc71;
        }
        .action-button:hover {
            background-color: #27ae60;
        }
        .file-input {
            display: none;
        }
        .file-label {
            display: inline-block;
            padding: 8px 12px;
            background-color: #9b59b6;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .file-label:hover {
            background-color: #8e44ad;
        }
        .mask-thumbnail {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .mask-item {
            width: 60px;
            height: 60px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            overflow: hidden;
            transition: transform 0.2s;
        }
        .mask-item:hover {
            transform: scale(1.05);
            border-color: #3498db;
        }
        .mask-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .instructions {
            background-color: #f0f8ff;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            border-left: 4px solid #3498db;
        }
        .drawing-tools {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        input[type="range"] {
            width: 100px;
        }
        input[type="color"] {
            width: 30px;
            height: 30px;
            padding: 0;
            border: none;
            cursor: pointer;
        }
        .footer {
            text-align: center;
            margin-top: 30px;
            color: #7f8c8d;
            font-size: 14px;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
            color: white;
        }
        .loading-spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin-bottom: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .debug-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            font-size: 10px;
            border-radius: 3px;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>周波数領域フィルタリングツール</h1>
        
        <div class="control-panel">
            <div class="button-group">
                <button id="load-image" class="action-button">デフォルト画像を読み込む</button>
                <label for="image-upload" class="file-label">画像をアップロード</label>
                <input type="file" id="image-upload" class="file-input" accept="image/*">
                <button id="reset-all">すべてリセット</button>
            </div>
            
            <h3>フィルタプリセット:</h3>
            <div class="button-group">
                <button id="low-pass" class="filter-preset">ローパスフィルタ</button>
                <button id="high-pass" class="filter-preset">ハイパスフィルタ</button>
                <button id="band-pass" class="filter-preset">バンドパスフィルタ</button>
                <button id="notch-filter" class="filter-preset">ノッチフィルタ</button>
                <button id="directional-h" class="filter-preset">水平方向性フィルタ</button>
                <button id="directional-v" class="filter-preset">垂直方向性フィルタ</button>
                <button id="clear-mask" class="filter-preset">マスククリア</button>
            </div>
            
            <h3>マスク作成ツール:</h3>
            <div class="drawing-tools">
                <button id="draw-mode" class="active">描画モード</button>
                <button id="erase-mode">消去モード</button>
                <label>ブラシサイズ: </label>
                <input type="range" id="brush-size" min="1" max="50" value="10">
                <span id="brush-size-value">10px</span>
                <button id="apply-mask" class="action-button">マスクを適用</button>
            </div>
        </div>
        
        <div class="grid-container">
            <div class="canvas-container">
                <canvas id="original-canvas"></canvas>
                <div class="canvas-label">元画像</div>
            </div>
            <div class="canvas-container">
                <canvas id="result-canvas"></canvas>
                <div class="canvas-label">処理結果</div>
            </div>
            <div class="canvas-container">
                <canvas id="frequency-canvas"></canvas>
                <div class="canvas-label">周波数スペクトル</div>
            </div>
            <div class="canvas-container">
                <canvas id="mask-canvas"></canvas>
                <div class="canvas-label">周波数マスク</div>
            </div>
        </div>
        
        <div class="instructions">
            <h2>使い方</h2>
            <ol>
                <li>「デフォルト画像を読み込む」ボタンをクリックするか、自分の画像をアップロードします。</li>
                <li>画像が読み込まれると、自動的にフーリエ変換が実行され、周波数スペクトルが表示されます。</li>
                <li>フィルタプリセットを選択するか、マスクキャンバス上でマスクを作成します。</li>
                <li>マスク作成後、「マスクを適用」ボタンをクリックして処理結果を確認します。</li>
            </ol>
            
            <h3>マスク作成の方法:</h3>
            <ul>
                <li><strong>描画モード:</strong> マスクキャンバス上で白く描画した部分が通過する周波数成分になります</li>
                <li><strong>消去モード:</strong> 描画したマスクを消去できます</li>
                <li><strong>ブラシサイズ:</strong> スライダーを使って描画のサイズを調整できます</li>
            </ul>
            
            <h2>フィルタの説明</h2>
            <ul>
                <li><strong>ローパスフィルタ:</strong> 低周波成分を通過させ、高周波成分を除去します。画像の細かい部分が滑らかになります。</li>
                <li><strong>ハイパスフィルタ:</strong> 高周波成分を通過させ、低周波成分を除去します。エッジや細部が強調されます。</li>
                <li><strong>バンドパスフィルタ:</strong> 特定の周波数帯域のみを通過させます。特定のテクスチャのみを抽出できます。</li>
                <li><strong>ノッチフィルタ:</strong> 特定の周波数帯域を除去します。ノイズ除去などに使用できます。</li>
                <li><strong>水平方向性フィルタ:</strong> 水平方向の周波数成分のみを通過させます。垂直エッジを強調します。</li>
                <li><strong>垂直方向性フィルタ:</strong> 垂直方向の周波数成分のみを通過させます。水平エッジを強調します。</li>
            </ul>
            
            <h2>技術的な説明</h2>
            <p>このツールでは以下の処理を行っています：</p>
            <ol>
                <li>入力画像をグレースケールに変換します</li>
                <li>高速フーリエ変換（FFT）を適用して周波数領域に変換します</li>
                <li>周波数領域でマスクを適用します</li>
                <li>逆フーリエ変換（IFFT）を適用して空間領域に戻します</li>
            </ol>
            <p>周波数スペクトルは対数スケールで表示しています。中心が低周波成分、外側が高周波成分です。</p>
        </div>
        
        <div class="footer">
            <p>© 2025 周波数領域フィルタリングツール - 画像処理学習用</p>
        </div>
    </div>
    
    <div id="loading-overlay" class="loading-overlay" style="display: none;">
        <div class="loading-spinner"></div>
        <p id="loading-message">処理中...</p>
    </div>
    
    <div id="debug-info" class="debug-info"></div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // デバッグ情報の表示機能
            const debugInfo = document.getElementById('debug-info');
            function log(message) {
                console.log(message);
                debugInfo.textContent += message + "\n";
                debugInfo.style.display = 'block';
            }
            
            // キャンバス要素の取得
            const originalCanvas = document.getElementById('original-canvas');
            const resultCanvas = document.getElementById('result-canvas');
            const frequencyCanvas = document.getElementById('frequency-canvas');
            const maskCanvas = document.getElementById('mask-canvas');
            
            // コンテキストの取得
            const originalCtx = originalCanvas.getContext('2d');
            const resultCtx = resultCanvas.getContext('2d');
            const frequencyCtx = frequencyCanvas.getContext('2d');
            const maskCtx = maskCanvas.getContext('2d');
            
            // ローディングオーバーレイ
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingMessage = document.getElementById('loading-message');
            
            // キャンバスのサイズ設定（2のべき乗であるべき）
            const canvasSize = 256; // 計算効率のため小さめに設定
            
            originalCanvas.width = originalCanvas.height = canvasSize;
            resultCanvas.width = resultCanvas.height = canvasSize;
            frequencyCanvas.width = frequencyCanvas.height = canvasSize;
            maskCanvas.width = maskCanvas.height = canvasSize;
            
            // 描画関連の変数
            let isDrawing = false;
            let drawMode = true; // true: 描画, false: 消去
            let brushSize = 10;
            
            // 元画像とフーリエ変換データ
            let originalImageData = null;
            let complexImage = null; // 複素数画像データ（フーリエ変換結果）
            
            // マスク描画モードの設定
            const drawModeBtn = document.getElementById('draw-mode');
            const eraseModeBtn = document.getElementById('erase-mode');
            const brushSizeInput = document.getElementById('brush-size');
            const brushSizeValue = document.getElementById('brush-size-value');
            
            drawModeBtn.addEventListener('click', () => {
                drawMode = true;
                drawModeBtn.classList.add('active');
                eraseModeBtn.classList.remove('active');
            });
            
            eraseModeBtn.addEventListener('click', () => {
                drawMode = false;
                eraseModeBtn.classList.add('active');
                drawModeBtn.classList.remove('active');
            });
            
            brushSizeInput.addEventListener('input', () => {
                brushSize = parseInt(brushSizeInput.value);
                brushSizeValue.textContent = `${brushSize}px`;
            });
            
            // マスクキャンバスの描画処理
            maskCanvas.addEventListener('mousedown', startDrawing);
            maskCanvas.addEventListener('mousemove', draw);
            maskCanvas.addEventListener('mouseup', stopDrawing);
            maskCanvas.addEventListener('mouseout', stopDrawing);
            
            function startDrawing(e) {
                isDrawing = true;
                draw(e);
            }
            
            function draw(e) {
                if (!isDrawing) return;
                
                const rect = maskCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (canvasSize / rect.width);
                const y = (e.clientY - rect.top) * (canvasSize / rect.height);
                
                maskCtx.beginPath();
                maskCtx.arc(x, y, brushSize, 0, Math.PI * 2);
                maskCtx.fillStyle = drawMode ? 'white' : 'black';
                maskCtx.fill();
            }
            
            function stopDrawing() {
                isDrawing = false;
            }
            
            // 画像の読み込み
            const loadImageBtn = document.getElementById('load-image');
            const imageUploadInput = document.getElementById('image-upload');
            const resetAllBtn = document.getElementById('reset-all');
            
            loadImageBtn.addEventListener('click', loadDefaultImage);
            imageUploadInput.addEventListener('change', loadUploadedImage);
            resetAllBtn.addEventListener('click', resetAll);
            
            // デフォルト画像の読み込み
            function loadDefaultImage() {
                console.log("Loading default image...");
                showLoading('デフォルト画像を読み込み中...');
                
                const img = new Image();
                // 最初に.jpegで試す
                // img.src = 'a.jpg';
                // img.crossOrigin = "Anonymous";
                
                img.onload = function() {
                    console.log("Default image loaded:", img.width, "x", img.height);
                    
                    // 画像をキャンバスサイズに合わせて描画
                    originalCtx.clearRect(0, 0, canvasSize, canvasSize);
                    
                    // 画像を中央に配置し、キャンバスの範囲内に収める
                    const scale = Math.min(canvasSize / img.width, canvasSize / img.height);
                    const x = (canvasSize - img.width * scale) / 2;
                    const y = (canvasSize - img.height * scale) / 2;
                    
                    originalCtx.drawImage(img, x, y, img.width * scale, img.height * scale);
                    
                    // グレースケール変換
                    const imageData = originalCtx.getImageData(0, 0, canvasSize, canvasSize);
                    const grayImageData = convertToGrayscale(imageData);
                    originalCtx.putImageData(grayImageData, 0, 0);
                    
                    // データを保存
                    originalImageData = grayImageData;
                    
                    // 初期マスク（すべて通過）
                    initializeMask();
                    
                    // フーリエ変換を実行
                    performFFT();
                    
                    hideLoading();
                };
                
                img.onerror = function(e) {
                    console.error("Default image loading error:", e);
                    console.log("Trying alternate file name format...");
                    
                    // 拡張子を変えて再試行
                    const altImg = new Image();
                    altImg.crossOrigin = "Anonymous";
                    
                    altImg.onload = function() {
                        console.log("Alternate image loaded successfully");
                        
                        // 画像をキャンバスサイズに合わせて描画
                        originalCtx.clearRect(0, 0, canvasSize, canvasSize);
                        
                        const scale = Math.min(canvasSize / altImg.width, canvasSize / altImg.height);
                        const x = (canvasSize - altImg.width * scale) / 2;
                        const y = (canvasSize - altImg.height * scale) / 2;
                        
                        originalCtx.drawImage(altImg, x, y, altImg.width * scale, altImg.height * scale);
                        
                        const imageData = originalCtx.getImageData(0, 0, canvasSize, canvasSize);
                        const grayImageData = convertToGrayscale(imageData);
                        originalCtx.putImageData(grayImageData, 0, 0);
                        
                        originalImageData = grayImageData;
                        initializeMask();
                        performFFT();
                        
                        hideLoading();
                    };
                    
                    altImg.onerror = function(e) {
                        console.error("Alternate image loading error:", e);
                        
                        // どちらの拡張子でも読み込めない場合はフォールバック画像を作成
                        createFallbackImage();
                    };
                    
                    // 拡張子を.jpgに変更して試行
                    altImg.src = 'a.jpg' + new Date().getTime();
                };
                
                最初に.jpegで試す
                img.src = 'a.jpg'  + new Date().getTime();
            }
            
            // フォールバック用のデフォルト画像作成
            function createFallbackImage() {
                console.log("Creating fallback image...");
                showLoading('代替画像を作成中...');
                
                // テスト用デフォルト画像の作成
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = tempCanvas.height = canvasSize;
                const tempCtx = tempCanvas.getContext('2d');
                
                // 簡単なテスト画像を作成（白黒のチェック模様）
                tempCtx.fillStyle = 'black';
                tempCtx.fillRect(0, 0, canvasSize, canvasSize);
                tempCtx.fillStyle = 'white';
                
                // 正方形パターンを描画
                const blockSize = canvasSize / 16;
                for (let y = 0; y < 16; y++) {
                    for (let x = 0; x < 16; x++) {
                        if ((x + y) % 2 === 0) {
                            tempCtx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
                        }
                    }
                }
                
                // キャンバスに描画
                const imageData = tempCtx.getImageData(0, 0, canvasSize, canvasSize);
                originalCtx.putImageData(imageData, 0, 0);
                originalImageData = imageData;
                
                console.log("Fallback image created.");
                
                // 初期マスク（すべて通過）を作成
                initializeMask();
                
                // FFT処理を実行
                performFFT();
                
                alert('デフォルト画像の読み込みに失敗しました。代替画像を使用します。');
                hideLoading();
            }
            
            function loadUploadedImage(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                console.log("Loading uploaded image:", file.name);
                showLoading('画像を読み込み中...');
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        console.log("Image loaded:", img.width, "x", img.height);
                        
                        // 画像をキャンバスサイズに合わせて描画
                        originalCtx.clearRect(0, 0, canvasSize, canvasSize);
                        
                        // 画像を中央に配置し、キャンバスの範囲内に収める
                        const scale = Math.min(canvasSize / img.width, canvasSize / img.height);
                        const x = (canvasSize - img.width * scale) / 2;
                        const y = (canvasSize - img.height * scale) / 2;
                        
                        originalCtx.drawImage(img, x, y, img.width * scale, img.height * scale);
                        
                        // グレースケール変換
                        const imageData = originalCtx.getImageData(0, 0, canvasSize, canvasSize);
                        const grayImageData = convertToGrayscale(imageData);
                        originalCtx.putImageData(grayImageData, 0, 0);
                        
                        // データを保存
                        originalImageData = grayImageData;
                        
                        // 初期マスク（すべて通過）
                        initializeMask();
                        
                        // フーリエ変換を実行
                        performFFT();
                        
                        hideLoading();
                    };
                    img.onerror = function(e) {
                        console.error("Image loading error:", e);
                        hideLoading();
                        alert('画像の読み込みに失敗しました。');
                    };
                    img.src = event.target.result;
                };
                reader.onerror = function(e) {
                    console.error("FileReader error:", e);
                    hideLoading();
                    alert('ファイルの読み込みに失敗しました。');
                };
                reader.readAsDataURL(file);
            }
            
            function convertToGrayscale(imageData) {
                const data = imageData.data;
                const newImageData = new ImageData(imageData.width, imageData.height);
                const newData = newImageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const gray = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);
                    newData[i] = gray;     // R
                    newData[i + 1] = gray; // G
                    newData[i + 2] = gray; // B
                    newData[i + 3] = 255;  // A
                }
                
                return newImageData;
            }
            
            // フーリエ変換用の複素数クラス
            class Complex {
                constructor(real = 0, imag = 0) {
                    this.real = real;
                    this.imag = imag;
                }
                
                // 絶対値を計算
                magnitude() {
                    return Math.sqrt(this.real * this.real + this.imag * this.imag);
                }
                
                // 加算
                add(other) {
                    return new Complex(this.real + other.real, this.imag + other.imag);
                }
                
                // 減算
                subtract(other) {
                    return new Complex(this.real - other.real, this.imag - other.imag);
                }
                
                // 乗算
                multiply(other) {
                    return new Complex(
                        this.real * other.real - this.imag * other.imag,
                        this.real * other.imag + this.imag * other.real
                    );
                }
                
                // スカラー乗算
                scale(scalar) {
                    return new Complex(this.real * scalar, this.imag * scalar);
                }
            }
            
            // 2次元FFT実装 - 修正版
            function fft2d(imageData) {
                console.log("Starting 2D FFT...");
                const width = imageData.width;
                const height = imageData.height;
                const data = imageData.data;
                
                // キャンバスサイズが2の累乗であることを確認
                if ((width & (width - 1)) !== 0 || (height & (height - 1)) !== 0) {
                    console.error("Image dimensions must be a power of 2");
                    throw new Error("Image dimensions must be a power of 2");
                }
                
                // 複素数配列に変換
                const complexArray = new Array(height);
                for (let y = 0; y < height; y++) {
                    complexArray[y] = new Array(width);
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        // dataの範囲チェック
                        if (i < data.length) {
                            complexArray[y][x] = new Complex(data[i], 0);
                        } else {
                            complexArray[y][x] = new Complex(0, 0);
                        }
                    }
                }
                
                console.log("Applying FFT to rows...");
                // 各行にFFTを適用
                for (let y = 0; y < height; y++) {
                    try {
                        complexArray[y] = fft1d(complexArray[y]);
                    } catch (e) {
                        console.error(`Error in row FFT at row ${y}:`, e);
                        // エラー発生時は空の配列で埋める
                        complexArray[y] = new Array(width).fill(new Complex(0, 0));
                    }
                }
                
                console.log("Applying FFT to columns...");
                // 転置して各列にFFTを適用
                try {
                    const transposed = transpose(complexArray);
                    for (let x = 0; x < width; x++) {
                        try {
                            transposed[x] = fft1d(transposed[x]);
                        } catch (e) {
                            console.error(`Error in column FFT at column ${x}:`, e);
                            // エラー発生時は空の配列で埋める
                            transposed[x] = new Array(height).fill(new Complex(0, 0));
                        }
                    }
                    
                    // 結果を元の形式に戻す
                    return transpose(transposed);
                } catch (e) {
                    console.error("Error during transpose operation:", e);
                    // エラー時はデフォルト値で埋めた配列を返す
                    const result = new Array(height);
                    for (let y = 0; y < height; y++) {
                        result[y] = new Array(width).fill(new Complex(0, 0));
                    }
                    return result;
                }
            }
            
            // 1次元FFT（クーリー・テューキーアルゴリズム）の修正
            function fft1d(inputArray) {
                const n = inputArray.length;
                
                // 再帰の終了条件
                if (n === 1) {
                    return [inputArray[0]];
                }
                
                // サイズが2のべき乗であることを確認
                if (n & (n - 1)) {
                    console.error("FFT size must be a power of 2");
                    throw new Error("FFT size must be a power of 2");
                }
                
                // 偶数インデックスと奇数インデックスに分割
                const even = new Array(n / 2);
                const odd = new Array(n / 2);
                for (let i = 0; i < n / 2; i++) {
                    even[i] = inputArray[i * 2];
                    odd[i] = inputArray[i * 2 + 1];
                }
                
                // 再帰的にFFTを計算
                const evenFFT = fft1d(even);
                const oddFFT = fft1d(odd);
                
                // 結果を結合
                const result = new Array(n);
                for (let k = 0; k < n / 2; k++) {
                    const kth = -2 * Math.PI * k / n;
                    const wk = new Complex(Math.cos(kth), Math.sin(kth));
                    
                    // ここでundefinedチェックを追加
                    if (!evenFFT[k] || !oddFFT[k]) {
                        console.error("Undefined value detected", { k, evenLength: evenFFT.length, oddLength: oddFFT.length });
                        // デフォルト値を設定
                        result[k] = new Complex(0, 0);
                        result[k + n / 2] = new Complex(0, 0);
                        continue;
                    }
                    
                    const oddTerm = wk.multiply(oddFFT[k]);
                    
                    result[k] = evenFFT[k].add(oddTerm);
                    result[k + n / 2] = evenFFT[k].subtract(oddTerm);
                }
                
                return result;
            }