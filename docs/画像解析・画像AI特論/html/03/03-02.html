<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>サンプリング比較ツール</title>
  <style>
    .container {
      font-family: 'Helvetica Neue', Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f9f9f9;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .control-panel {
      margin-bottom: 20px;
      padding: 15px;
      background-color: #f0f0f0;
      border-radius: 6px;
    }
    label {
      font-weight: bold;
      margin-right: 10px;
    }
    input[type="range"] {
      width: 300px;
      margin-right: 10px;
    }
    .value-display {
      display: inline-block;
      width: 60px;
      text-align: center;
      font-weight: bold;
    }
    .info-text {
      font-size: 14px;
      color: #666;
      margin-top: 5px;
    }
    
    /* デモ用スタイル */
    .comparison-container, .spectrum-container {
      display: flex;
      flex-direction: row; /* 横並び */
      gap: 20px; /* パネル間のスペース */
      margin-top: 20px;
    }
    
    .demo-panel, .spectrum-panel {
      flex: 1; /* 均等に幅を分配 */
      background-color: #fff;
      padding: 15px;
      border-radius: 6px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.1);
    }
    
    .spectrum-panel {
      height: 250px; /* 周波数スペクトル表示用パネルの高さ */
    }
    
    .sampling-options {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
    }
    
    .sampling-options label {
      margin-right: 20px;
      font-weight: normal;
      display: flex;
      align-items: center;
    }
    
    .sampling-options input[type="checkbox"] {
      margin-right: 5px;
    }
    
    .info-box {
      margin-top: 15px;
      padding: 10px;
      background-color: #f5f5f5;
      border-radius: 4px;
      font-size: 13px;
    }
    
    .info-box p {
      margin: 5px 0;
    }
    
    .panel-title {
      font-weight: bold;
      margin-bottom: 10px;
      text-align: center;
      font-size: 16px;
    }
    
    canvas {
      width: 100%;
      border: 1px solid #ddd;
    }
    
    /* レジェンド */
    .legend {
      display: flex;
      justify-content: center;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      margin: 0 10px;
    }
    
    .legend-color {
      width: 15px;
      height: 3px;
      margin-right: 5px;
    }
    
    .legend-point {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 5px;
    }
    
    .legend-bar {
      width: 15px;
      height: 15px;
      margin-right: 5px;
    }
    
    /* レスポンシブデザイン */
    @media (max-width: 768px) {
      .comparison-container, .spectrum-container {
        flex-direction: column; /* 画面が小さい場合は縦並びに戻す */
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>低周波成分と合成波のサンプリング比較ツール</h2>
    
    <!-- 共通コントロールパネル -->
    <div class="control-panel">
      <h3>サンプリング間隔の設定</h3>
      <div>
        <label for="samplingRate">標本化間隔:</label>
        <input type="range" id="samplingRate" min="1" max="40" value="10" step="1">
        <span id="samplingDisplay" class="value-display">10</span>
        <span class="info-text">（低い値=高密度サンプリング、高い値=低密度サンプリング）</span>
      </div>
      <div class="sampling-options">
        <label><input type="checkbox" id="showOriginalSignal" checked> 元の信号を表示</label>
        <label><input type="checkbox" id="showSampledPoints" checked> 標本点を表示</label>
        <label><input type="checkbox" id="showReconstructed" checked> 再構成信号を表示</label>
        <label><input type="checkbox" id="showComponents" checked> 成分波形を表示（合成波パネルのみ）</label>
      </div>
      <div class="info-text" style="margin-top: 10px;">
        * 標本化間隔スライダーを動かして、両パネルでのサンプリング結果の違いを比較できます。<br>
        * サンプリング定理（ナイキスト・シャノンの定理）: 信号の最高周波数の2倍以上のサンプリング周波数が必要です。
      </div>
    </div>
    
    <!-- 比較表示エリア（横並び） -->
    <div class="comparison-container">
      <!-- 低周波成分サンプリングパネル -->
      <div class="demo-panel">
        <div class="panel-title">低周波成分のサンプリング</div>
        <canvas id="lowFreqCanvas"></canvas>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(255, 165, 0, 0.8);"></div>
            <span>低周波信号</span>
          </div>
          <div class="legend-item">
            <div class="legend-point" style="background-color: rgba(0, 0, 255, 0.8);"></div>
            <span>標本点</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(0, 180, 0, 0.8);"></div>
            <span>再構成信号</span>
          </div>
        </div>
        <div class="info-box">
          <p>低周波成分（周波数 = 2Hz）のみのサンプリングと再構成を表示しています。</p>
          <p>低周波の場合、比較的少ないサンプリング点数でも元の信号を正確に再構成できることが分かります。</p>
        </div>
      </div>
      
      <!-- 合成波サンプリングパネル -->
      <div class="demo-panel">
        <div class="panel-title">合成波のサンプリング</div>
        <canvas id="compositeCanvas"></canvas>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(255, 0, 0, 0.8);"></div>
            <span>合成波</span>
          </div>
          <div class="legend-item">
            <div class="legend-point" style="background-color: rgba(0, 0, 255, 0.8);"></div>
            <span>標本点</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(0, 180, 0, 0.8);"></div>
            <span>再構成信号</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(128, 0, 128, 0.5);"></div>
            <span>高周波成分</span>
          </div>
        </div>
        <div class="info-box">
          <p>低周波成分と高周波成分（周波数 = 6Hz）を合成した信号のサンプリングと再構成を表示しています。</p>
          <p>合成波には高周波成分が含まれるため、低周波成分のみの場合より高いサンプリング周波数が必要です。</p>
        </div>
      </div>
    </div>
    
    <!-- 周波数プロファイル表示エリア（横並び） -->
    <div class="spectrum-container">
      <!-- 低周波成分の周波数プロファイル -->
      <div class="spectrum-panel">
        <div class="panel-title">低周波成分の周波数プロファイル</div>
        <canvas id="lowFreqSpectrumCanvas"></canvas>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-bar" style="background-color: rgba(255, 165, 0, 0.6);"></div>
            <span>元の信号のスペクトル</span>
          </div>
          <div class="legend-item">
            <div class="legend-bar" style="background-color: rgba(0, 180, 0, 0.6);"></div>
            <span>再構成信号のスペクトル</span>
          </div>
        </div>
      </div>
      
      <!-- 合成波の周波数プロファイル -->
      <div class="spectrum-panel">
        <div class="panel-title">合成波の周波数プロファイル</div>
        <canvas id="compositeSpectrumCanvas"></canvas>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-bar" style="background-color: rgba(255, 0, 0, 0.6);"></div>
            <span>元の信号のスペクトル</span>
          </div>
          <div class="legend-item">
            <div class="legend-bar" style="background-color: rgba(0, 180, 0, 0.6);"></div>
            <span>再構成信号のスペクトル</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // キャンバスの設定
    const lowFreqCanvas = document.getElementById('lowFreqCanvas');
    const compositeCanvas = document.getElementById('compositeCanvas');
    const lowFreqSpectrumCanvas = document.getElementById('lowFreqSpectrumCanvas');
    const compositeSpectrumCanvas = document.getElementById('compositeSpectrumCanvas');
    
    // 時間領域のキャンバスサイズ
    lowFreqCanvas.width = 600;
    lowFreqCanvas.height = 300;
    compositeCanvas.width = 600;
    compositeCanvas.height = 300;
    
    // 周波数領域のキャンバスサイズ
    lowFreqSpectrumCanvas.width = 600;
    lowFreqSpectrumCanvas.height = 200;
    compositeSpectrumCanvas.width = 600;
    compositeSpectrumCanvas.height = 200;
    
    // コンテキスト取得
    const lowFreqCtx = lowFreqCanvas.getContext('2d');
    const compositeCtx = compositeCanvas.getContext('2d');
    const lowFreqSpectrumCtx = lowFreqSpectrumCanvas.getContext('2d');
    const compositeSpectrumCtx = compositeSpectrumCanvas.getContext('2d');
    
    // スライダーとチェックボックスの設定
    const samplingSlider = document.getElementById('samplingRate');
    const samplingDisplay = document.getElementById('samplingDisplay');
    const showOriginalCheckbox = document.getElementById('showOriginalSignal');
    const showSampledCheckbox = document.getElementById('showSampledPoints');
    const showReconstructedCheckbox = document.getElementById('showReconstructed');
    const showComponentsCheckbox = document.getElementById('showComponents');
    
    // グリッドの描画
    function drawGrid(ctx, width, height) {
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 0.5;
      
      // 水平グリッド
      for (let y = 0; y < height; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      
      // 垂直グリッド
      for (let x = 0; x < width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      // 中心線（Y=0）
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, height / 2);
      ctx.lineTo(width, height / 2);
      ctx.stroke();
    }
    
    // スペクトル表示用のグリッド
    function drawSpectrumGrid(ctx, width, height) {
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 0.5;
      
      // 水平グリッド
      for (let y = 0; y < height; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      
      // 垂直グリッド
      for (let x = 0; x < width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      // 下部の線
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, height - 1);
      ctx.lineTo(width, height - 1);
      ctx.stroke();
    }
    
    // 軸ラベルの描画
    function drawAxisLabels(ctx, width, height, samplingInterval, additionalInfo = '') {
      ctx.fillStyle = '#333';
      ctx.font = '12px Arial';
      
      // X軸ラベル
      ctx.textAlign = 'center';
      ctx.fillText('時間 →', width / 2, height - 10);
      
      // Y軸ラベル
      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.fillText('振幅', 0, 0);
      ctx.restore();
      
      // ナイキスト周波数と追加情報の表示
      const nyquistFreq = 1 / (2 * samplingInterval);
      ctx.textAlign = 'start';
      ctx.fillText(`サンプリング間隔: ${samplingInterval}`, 10, 20);
      ctx.fillText(`ナイキスト周波数: ${nyquistFreq.toFixed(3)}`, 10, 40);
      
      if (additionalInfo) {
        ctx.fillText(additionalInfo, 10, 60);
      }
    }
    
    // スペクトル用軸ラベル
    function drawSpectrumLabels(ctx, width, height, nyquistFreq) {
      ctx.fillStyle = '#333';
      ctx.font = '12px Arial';
      
      // X軸ラベル
      ctx.textAlign = 'center';
      ctx.fillText('周波数 →', width / 2, height - 5);
      
      // Y軸ラベル
      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.fillText('振幅', 0, 0);
      ctx.restore();
      
      // 周波数マーカーを描画（0.1Hzごと）
      ctx.textAlign = 'center';
      const maxFreq = 10; // 表示最大周波数
      const freqScale = width / maxFreq;
      
      for (let freq = 0; freq <= maxFreq; freq += 1) {
        const x = freq * freqScale;
        // 大きな目盛りは1Hz間隔
        if (freq % 1 === 0) {
          ctx.fillText(`${freq}`, x, height - 20);
          // ナイキスト周波数を表示
          if (Math.abs(freq - nyquistFreq) < 0.1 && nyquistFreq < maxFreq) {
            ctx.fillStyle = 'rgba(255,0,0,0.7)';
            ctx.fillText(`Nyquist`, nyquistFreq * freqScale, height - 35);
            // ナイキスト周波数の垂直線
            ctx.strokeStyle = 'rgba(255,0,0,0.5)';
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(nyquistFreq * freqScale, 0);
            ctx.lineTo(nyquistFreq * freqScale, height - 40);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#333';
          }
        }
      }
    }
    
    // 再構成信号の計算（シンク関数の近似）
    function reconstructSignal(x, sampledPoints, samplingInterval) {
      // シンプルな場合の再構成（スプライン補間の簡易版）
      let sum = 0;
      let weightSum = 0;
      
      // 各サンプル点からの寄与を計算
      for (const point of sampledPoints) {
        const distance = Math.abs(x - point.x);
        // 距離に基づく重み（シンク関数の簡易近似）
        let weight;
        if (distance === 0) {
          weight = 1;
        } else {
          // 距離が近いほど大きい重み
          weight = Math.max(0, 1 - distance / (samplingInterval * 3));
        }
        
        sum += point.y * weight;
        weightSum += weight;
      }
      
      // 正規化
      return weightSum > 0 ? sum / weightSum : sampledPoints[0]?.y || 0;
    }
    
    // 低周波信号の生成
    function lowFreqSignal(x, centerY, amplitude, period) {
      return centerY - Math.sin(x * 2 * Math.PI / period) * amplitude * 0.7;
    }
    
    // 高周波信号の生成
    function highFreqSignal(x, centerY, amplitude, period) {
      return centerY - Math.sin(x * 6 * Math.PI / period) * amplitude * 0.3;
    }
    
    // 合成信号の生成
    function compositeSignal(x, centerY, amplitude, period) {
      return lowFreqSignal(x, centerY, amplitude, period) - centerY + 
             highFreqSignal(x, centerY, amplitude, period) - centerY + centerY;
    }
    
    // 簡易的なFFT計算（実際のFFTではなく、解析的に計算）
    function calculateSpectrum(signal, maxFreq, numPoints) {
      const spectrum = new Array(numPoints).fill(0);
      
      // 低周波成分のみの場合（2Hz）
      if (signal === 'lowFreq') {
        const peak1 = Math.floor(numPoints * 2 / maxFreq);
        spectrum[peak1] = 0.7; // 低周波ピーク
      } 
      // 合成波の場合（2Hzと6Hz）
      else if (signal === 'composite') {
        const peak1 = Math.floor(numPoints * 2 / maxFreq);
        const peak2 = Math.floor(numPoints * 6 / maxFreq);
        spectrum[peak1] = 0.7; // 低周波ピーク
        spectrum[peak2] = 0.3; // 高周波ピーク
      }
      // 再構成信号の場合（サンプリング間隔に依存）
      else if (signal === 'reconstructedLow' || signal === 'reconstructedComposite') {
        const samplingInterval = parseInt(samplingSlider.value);
        const nyquistFreq = 1 / (2 * samplingInterval);
        
        if (signal === 'reconstructedLow') {
          // 低周波のみのスペクトル
          const peak1 = Math.floor(numPoints * 2 / maxFreq);
          // ナイキスト周波数未満なら正確に再現
          if (2 < nyquistFreq) {
            spectrum[peak1] = 0.7;
          } else {
            // 不正確な再現（エイリアシング）
            const aliasFreq = 2 % (2 * nyquistFreq);
            const aliasPeak = Math.floor(numPoints * aliasFreq / maxFreq);
            spectrum[aliasPeak] = 0.7 * 0.8; // 減衰を加味
          }
        } else {
          // 合成波のスペクトル
          const peak1 = Math.floor(numPoints * 2 / maxFreq);
          const peak2 = Math.floor(numPoints * 6 / maxFreq);
          
          // 低周波成分（2Hz）のチェック
          if (2 < nyquistFreq) {
            spectrum[peak1] = 0.7;
          } else {
            const aliasFreq = 2 % (2 * nyquistFreq);
            const aliasPeak = Math.floor(numPoints * aliasFreq / maxFreq);
            spectrum[aliasPeak] = 0.7 * 0.8;
          }
          
          // 高周波成分（6Hz）のチェック
          if (6 < nyquistFreq) {
            spectrum[peak2] = 0.3;
          } else {
            const aliasFreq = 6 % (2 * nyquistFreq);
            const aliasPeak = Math.floor(numPoints * aliasFreq / maxFreq);
            spectrum[aliasPeak] = 0.3 * 0.8;
          }
        }
      }
      
      // スムージング（見た目を整える）
      const smoothedSpectrum = [];
      for (let i = 0; i < spectrum.length; i++) {
        if (spectrum[i] > 0) {
          // ピークをなだらかにする
          smoothedSpectrum[i] = spectrum[i];
          if (i > 0) smoothedSpectrum[i-1] = spectrum[i] * 0.3;
          if (i > 1) smoothedSpectrum[i-2] = spectrum[i] * 0.1;
          if (i < spectrum.length - 1) smoothedSpectrum[i+1] = spectrum[i] * 0.3;
          if (i < spectrum.length - 2) smoothedSpectrum[i+2] = spectrum[i] * 0.1;
        } else if (!smoothedSpectrum[i]) {
          smoothedSpectrum[i] = 0;
        }
      }
      
      return smoothedSpectrum;
    }
    
    // スペクトルの描画
    function drawSpectrum(ctx, spectrum, width, height, color) {
      const barWidth = width / spectrum.length;
      const maxAmplitude = Math.max(...spectrum) * 1.2; // マージンを追加
      
      // バーチャートとして描画
      ctx.fillStyle = color;
      
      for (let i = 0; i < spectrum.length; i++) {
        const barHeight = (spectrum[i] / maxAmplitude) * (height - 40);
        const x = i * barWidth;
        const y = height - barHeight - 1;
        
        ctx.fillRect(x, y, barWidth - 1, barHeight);
      }
    }
    
    // 低周波成分のサンプリングと再構成
    function drawLowFreqPanel(samplingInterval, showOriginal, showSampled, showReconstructed) {
      const width = lowFreqCanvas.width;
      const height = lowFreqCanvas.height;
      
      // キャンバスをクリア
      lowFreqCtx.clearRect(0, 0, width, height);
      
      // 背景グリッド
      drawGrid(lowFreqCtx, width, height);
      
      // パラメータ
      const centerY = height / 2;
      const amplitude = height / 4;
      const period = 100; // 基本周期
      
      // 低周波信号を描画
      if (showOriginal) {
        lowFreqCtx.beginPath();
        lowFreqCtx.strokeStyle = 'rgba(255, 165, 0, 0.8)'; // オレンジ
        lowFreqCtx.lineWidth = 2;
        
        for (let x = 0; x < width; x++) {
          const y = lowFreqSignal(x, centerY, amplitude, period);
          if (x === 0) {
            lowFreqCtx.moveTo(x, y);
          } else {
            lowFreqCtx.lineTo(x, y);
          }
        }
        lowFreqCtx.stroke();
      }
      
      // 標本点の取得（サンプリング間隔に基づく）
      const sampledPoints = [];
      for (let x = 0; x < width; x += samplingInterval) {
        sampledPoints.push({
          x: x,
          y: lowFreqSignal(x, centerY, amplitude, period)
        });
      }
      
      // 標本点を描画
      if (showSampled) {
        lowFreqCtx.fillStyle = 'rgba(0, 0, 255, 0.8)';
        for (const point of sampledPoints) {
          lowFreqCtx.beginPath();
          lowFreqCtx.arc(point.x, point.y, 4, 0, Math.PI * 2);
          lowFreqCtx.fill();
        }
      }
      
      // 再構成された信号を描画
      let reconstructedSignalPoints = [];
      if (showReconstructed) {
        lowFreqCtx.beginPath();
        lowFreqCtx.strokeStyle = 'rgba(0, 180, 0, 0.8)';
        lowFreqCtx.lineWidth = 2;
        
        for (let x = 0; x < width; x++) {
          const y = reconstructSignal(x, sampledPoints, samplingInterval);
          reconstructedSignalPoints.push(y);
          if (x === 0) {
            lowFreqCtx.moveTo(x, y);
          } else {
            lowFreqCtx.lineTo(x, y);
          }
        }
        lowFreqCtx.stroke();
      }
      
      // 軸ラベルと説明
      drawAxisLabels(lowFreqCtx, width, height, samplingInterval, '低周波: 2Hz');
      
      // スペクトル描画用に再構成信号を返す
      return reconstructedSignalPoints;
    }
    
    // 合成波のサンプリングと再構成
    function drawCompositePanel(samplingInterval, showOriginal, showSampled, showReconstructed, showComponents) {
      const width = compositeCanvas.width;
      const height = compositeCanvas.height;
      
      // キャンバスをクリア
      compositeCtx.clearRect(0, 0, width, height);
      
      // 背景グリッド
      drawGrid(compositeCtx, width, height);
      
      // パラメータ
      const centerY = height / 2;
      const amplitude = height / 4;
      const period = 100; // 基本周期
      
      // 周波数成分を描画
      if (showComponents) {
        // 低周波成分（薄く表示）
        compositeCtx.beginPath();
        compositeCtx.strokeStyle = 'rgba(255, 165, 0, 0.3)'; // オレンジ（薄く）
        compositeCtx.lineWidth = 1.5;
        
        for (let x = 0; x < width; x++) {
          const y = lowFreqSignal(x, centerY, amplitude, period);
          if (x === 0) {
            compositeCtx.moveTo(x, y);
          } else {
            compositeCtx.lineTo(x, y);
          }
        }
        compositeCtx.stroke();
        
// 高周波成分
compositeCtx.beginPath();
        compositeCtx.strokeStyle = 'rgba(128, 0, 128, 0.5)'; // 紫
        compositeCtx.lineWidth = 1.5;
        
        for (let x = 0; x < width; x++) {
          const y = highFreqSignal(x, centerY, amplitude, period);
          if (x === 0) {
            compositeCtx.moveTo(x, y);
          } else {
            compositeCtx.lineTo(x, y);
          }
        }
        compositeCtx.stroke();
      }
      
      // 元の信号を描画（合成波）
      if (showOriginal) {
        compositeCtx.beginPath();
        compositeCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
        compositeCtx.lineWidth = 2;
        
        for (let x = 0; x < width; x++) {
          const y = compositeSignal(x, centerY, amplitude, period);
          if (x === 0) {
            compositeCtx.moveTo(x, y);
          } else {
            compositeCtx.lineTo(x, y);
          }
        }
        compositeCtx.stroke();
      }
      
      // 標本点の取得（サンプリング間隔に基づく）
      const sampledPoints = [];
      for (let x = 0; x < width; x += samplingInterval) {
        sampledPoints.push({
          x: x,
          y: compositeSignal(x, centerY, amplitude, period)
        });
      }
      
      // 標本点を描画
      if (showSampled) {
        compositeCtx.fillStyle = 'rgba(0, 0, 255, 0.8)';
        for (const point of sampledPoints) {
          compositeCtx.beginPath();
          compositeCtx.arc(point.x, point.y, 4, 0, Math.PI * 2);
          compositeCtx.fill();
        }
      }
      
      // 再構成された信号を描画
      let reconstructedSignalPoints = [];
      if (showReconstructed) {
        compositeCtx.beginPath();
        compositeCtx.strokeStyle = 'rgba(0, 180, 0, 0.8)';
        compositeCtx.lineWidth = 2;
        
        for (let x = 0; x < width; x++) {
          const y = reconstructSignal(x, sampledPoints, samplingInterval);
          reconstructedSignalPoints.push(y);
          if (x === 0) {
            compositeCtx.moveTo(x, y);
          } else {
            compositeCtx.lineTo(x, y);
          }
        }
        compositeCtx.stroke();
      }
      
      // 軸ラベルと説明
      drawAxisLabels(compositeCtx, width, height, samplingInterval, '合成波 (低周波2Hz + 高周波6Hz)');
      
      // スペクトル描画用に再構成信号を返す
      return reconstructedSignalPoints;
    }
    
    // 低周波成分のスペクトル表示
    function drawLowFreqSpectrum(samplingInterval, showOriginal, showReconstructed) {
      const width = lowFreqSpectrumCanvas.width;
      const height = lowFreqSpectrumCanvas.height;
      
      // キャンバスをクリア
      lowFreqSpectrumCtx.clearRect(0, 0, width, height);
      
      // 背景グリッド
      drawSpectrumGrid(lowFreqSpectrumCtx, width, height);
      
      // ナイキスト周波数の計算
      const nyquistFreq = 1 / (2 * samplingInterval);
      
      // 周波数スケールの設定
      const maxFreq = 10; // Hz
      const numPoints = 100;
      
      // 元の信号のスペクトル
      if (showOriginal) {
        const originalSpectrum = calculateSpectrum('lowFreq', maxFreq, numPoints);
        drawSpectrum(lowFreqSpectrumCtx, originalSpectrum, width, height, 'rgba(255, 165, 0, 0.6)');
      }
      
      // 再構成信号のスペクトル
      if (showReconstructed) {
        const reconstructedSpectrum = calculateSpectrum('reconstructedLow', maxFreq, numPoints);
        drawSpectrum(lowFreqSpectrumCtx, reconstructedSpectrum, width, height, 'rgba(0, 180, 0, 0.6)');
      }
      
      // 軸ラベル
      drawSpectrumLabels(lowFreqSpectrumCtx, width, height, nyquistFreq);
    }
    
    // 合成波のスペクトル表示
    function drawCompositeSpectrum(samplingInterval, showOriginal, showReconstructed) {
      const width = compositeSpectrumCanvas.width;
      const height = compositeSpectrumCanvas.height;
      
      // キャンバスをクリア
      compositeSpectrumCtx.clearRect(0, 0, width, height);
      
      // 背景グリッド
      drawSpectrumGrid(compositeSpectrumCtx, width, height);
      
      // ナイキスト周波数の計算
      const nyquistFreq = 1 / (2 * samplingInterval);
      
      // 周波数スケールの設定
      const maxFreq = 10; // Hz
      const numPoints = 100;
      
      // 元の信号のスペクトル
      if (showOriginal) {
        const originalSpectrum = calculateSpectrum('composite', maxFreq, numPoints);
        drawSpectrum(compositeSpectrumCtx, originalSpectrum, width, height, 'rgba(255, 0, 0, 0.6)');
      }
      
      // 再構成信号のスペクトル
      if (showReconstructed) {
        const reconstructedSpectrum = calculateSpectrum('reconstructedComposite', maxFreq, numPoints);
        drawSpectrum(compositeSpectrumCtx, reconstructedSpectrum, width, height, 'rgba(0, 180, 0, 0.6)');
      }
      
      // 軸ラベル
      drawSpectrumLabels(compositeSpectrumCtx, width, height, nyquistFreq);
    }
    
    // 両パネルの更新
    function updatePanels() {
      const samplingInterval = parseInt(samplingSlider.value);
      samplingDisplay.textContent = samplingInterval;
      
      const showOriginal = showOriginalCheckbox.checked;
      const showSampled = showSampledCheckbox.checked;
      const showReconstructed = showReconstructedCheckbox.checked;
      const showComponents = showComponentsCheckbox.checked;
      
      // 時間領域パネルの描画
      drawLowFreqPanel(samplingInterval, showOriginal, showSampled, showReconstructed);
      drawCompositePanel(samplingInterval, showOriginal, showSampled, showReconstructed, showComponents);
      
      // 周波数領域パネルの描画
      drawLowFreqSpectrum(samplingInterval, showOriginal, showReconstructed);
      drawCompositeSpectrum(samplingInterval, showOriginal, showReconstructed);
    }
    
    // 初期化関数
    function init() {
      // イベントリスナー設定
      samplingSlider.addEventListener('input', updatePanels);
      showOriginalCheckbox.addEventListener('input', updatePanels);
      showSampledCheckbox.addEventListener('input', updatePanels);
      showReconstructedCheckbox.addEventListener('input', updatePanels);
      showComponentsCheckbox.addEventListener('input', updatePanels);
      
      // 初期表示
      updatePanels();
    }
    
    // ページロード時に初期化
    window.addEventListener('load', init);
  </script>
</body>
</html>