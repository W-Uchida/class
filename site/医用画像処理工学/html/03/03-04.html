<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>周波数成分可視化デモ - 2D フーリエ変換</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1, h2, h3 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        .container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .explanation {
            background-color: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 5px solid #3498db;
        }
        .canvas-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
            justify-content: center;
        }
        .canvas-container {
            position: relative;
            margin-bottom: 20px;
            text-align: center;
        }
        canvas {
            display: block;
            background: white;
            border: 1px solid #ddd;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .canvas-label {
            font-weight: bold;
            font-size: 14px;
            color: #2c3e50;
            margin-top: 5px;
        }
        .transform-arrow {
            font-size: 24px;
            font-weight: bold;
            color: #3498db;
            margin: 0 10px;
            align-self: center;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            margin: 5px;
        }
        button:hover {
            background-color: #2980b9;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .control-group {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            background-color: #f8f9fa;
        }
        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .control-row > label {
            width: 200px;
            font-weight: bold;
        }
        .control-row > input[type="range"] {
            flex: 1;
        }
        .control-row > output {
            width: 50px;
            text-align: center;
            margin-left: 10px;
        }
        #frequencyExplanation {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 3px solid #3498db;
        }
    </style>
</head>
<body>
    <h1>周波数成分可視化デモ - 2D フーリエ変換</h1>
    
    <div class="explanation">
        <h2>周波数成分の基本概念</h2>
        <p>2次元フーリエ変換を用いると、画像を<strong>低周波成分</strong>と<strong>高周波成分</strong>に分解することができます。</p>
        <ul>
            <li><strong>低周波成分</strong>: 画像の緩やかな変化、全体的な構造、滑らかな領域を表します。周波数空間の中心付近に現れます。</li>
            <li><strong>高周波成分</strong>: 画像の急激な変化、エッジ、細部、テクスチャを表します。周波数空間の外側に現れます。</li>
        </ul>
        <p>このデモでは、低周波成分と高周波成分が異なる画像を組み合わせ、周波数空間での表現を確認できます。</p>
    </div>

    <div class="container">
        <h2>周波数成分の可視化</h2>
        
        <div class="control-group">
            <h3>画像の周波数成分を調整</h3>
            <div class="control-row">
                <label for="lowFreqWeight">低周波成分の強さ:</label>
                <input type="range" id="lowFreqWeight" min="0" max="100" value="50">
                <output id="lowFreqOutput">50</output>
            </div>
            <div class="control-row">
                <label for="highFreqWeight">高周波成分の強さ:</label>
                <input type="range" id="highFreqWeight" min="0" max="100" value="50">
                <output id="highFreqOutput">50</output>
            </div>
            <div class="control-row">
                <label for="noiseLevel">ノイズの量:</label>
                <input type="range" id="noiseLevel" min="0" max="100" value="0">
                <output id="noiseOutput">0</output>
            </div>
            <button onclick="updateImage()">更新</button>
        </div>
        
        <div class="canvas-row">
            <div class="canvas-container">
                <canvas id="lowFreqCanvas" width="256" height="256"></canvas>
                <div class="canvas-label">低周波成分 (実空間)</div>
            </div>
            <div class="canvas-container">
                <canvas id="highFreqCanvas" width="256" height="256"></canvas>
                <div class="canvas-label">高周波成分 (実空間)</div>
            </div>
            <div class="canvas-container">
                <canvas id="combinedCanvas" width="256" height="256"></canvas>
                <div class="canvas-label">合成画像 (実空間)</div>
            </div>
        </div>
        
        <div class="canvas-row">
            <div class="canvas-container">
                <canvas id="lowFreqFourier" width="256" height="256"></canvas>
                <div class="canvas-label">低周波成分 (周波数空間)</div>
            </div>
            <div class="canvas-container">
                <canvas id="highFreqFourier" width="256" height="256"></canvas>
                <div class="canvas-label">高周波成分 (周波数空間)</div>
            </div>
            <div class="canvas-container">
                <canvas id="combinedFourier" width="256" height="256"></canvas>
                <div class="canvas-label">合成画像 (周波数空間)</div>
            </div>
        </div>
        
        <div class="button-group">
            <button onclick="generateLowFreq('gaussian')">滑らかな低周波画像</button>
            <button onclick="generateLowFreq('circle')">円形の低周波画像</button>
            <button onclick="generateHighFreq('edges')">水平方向の高周波sin波</button>
            <button onclick="generateHighFreq('texture')">垂直方向の高周波sin波</button>
            <button onclick="generateHighFreq('grid')">格子状の高周波sin波</button>
        </div>
        
        <div id="frequencyExplanation">
            スライダーを動かして低周波成分と高周波成分の強さを調整し、「更新」ボタンをクリックすると合成画像が更新されます。
            周波数空間では、低周波成分は中心付近に、高周波成分は外側に表示されます。
        </div>
    </div>

    <script>
        // キャンバス要素とコンテキストの取得
        const lowFreqCanvas = document.getElementById('lowFreqCanvas');
        const highFreqCanvas = document.getElementById('highFreqCanvas');
        const combinedCanvas = document.getElementById('combinedCanvas');
        const lowFreqFourier = document.getElementById('lowFreqFourier');
        const highFreqFourier = document.getElementById('highFreqFourier');
        const combinedFourier = document.getElementById('combinedFourier');
        
        const lowFreqCtx = lowFreqCanvas.getContext('2d');
        const highFreqCtx = highFreqCanvas.getContext('2d');
        const combinedCtx = combinedCanvas.getContext('2d');
        const lowFreqFourierCtx = lowFreqFourier.getContext('2d');
        const highFreqFourierCtx = highFreqFourier.getContext('2d');
        const combinedFourierCtx = combinedFourier.getContext('2d');
        
        // 現在選択されている高周波パターン
        let currentHighFreqType = 'edges';
        
        // スライダーの出力要素
        const lowFreqOutput = document.getElementById('lowFreqOutput');
        const highFreqOutput = document.getElementById('highFreqOutput');
        const noiseOutput = document.getElementById('noiseOutput');
        
        // スライダーの値を出力に反映
        document.getElementById('lowFreqWeight').addEventListener('input', function() {
            lowFreqOutput.value = this.value;
        });
        
        document.getElementById('highFreqWeight').addEventListener('input', function() {
            highFreqOutput.value = this.value;
        });
        
        document.getElementById('noiseLevel').addEventListener('input', function() {
            noiseOutput.value = this.value;
        });
        
        // 低周波画像の生成
        function generateLowFreq(type) {
            const width = lowFreqCanvas.width;
            const height = lowFreqCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // キャンバスをクリア
            lowFreqCtx.clearRect(0, 0, width, height);
            lowFreqCtx.fillStyle = 'white';
            lowFreqCtx.fillRect(0, 0, width, height);
            
            if (type === 'gaussian') {
                // ガウシアンの描画
                const sigma = width / 4; // 大きめのシグマで滑らかな変化
                const imageData = lowFreqCtx.createImageData(width, height);
                const data = imageData.data;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX;
                        const dy = y - centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const intensity = Math.exp(-(distance * distance) / (2 * sigma * sigma));
                        
                        const index = (y * width + x) * 4;
                        const value = Math.floor(255 * (1 - intensity * 0.8)); // コントラストを調整
                        data[index] = value;     // R
                        data[index + 1] = value; // G
                        data[index + 2] = value; // B
                        data[index + 3] = 255;   // A
                    }
                }
                
                lowFreqCtx.putImageData(imageData, 0, 0);
                
                // 説明更新
                document.getElementById('frequencyExplanation').textContent = 
                    'ガウシアン関数のような滑らかな変化を持つ画像は、周波数空間では中心付近に集中する低周波成分が支配的になります。';
            } else if (type === 'circle') {
                // 円形の描画（滑らかなエッジで）
                const gradient = lowFreqCtx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, width / 3
                );
                gradient.addColorStop(0, 'black');
                gradient.addColorStop(0.8, 'gray');
                gradient.addColorStop(1, 'white');
                
                lowFreqCtx.fillStyle = gradient;
                lowFreqCtx.beginPath();
                lowFreqCtx.arc(centerX, centerY, width / 3, 0, Math.PI * 2);
                lowFreqCtx.fill();
                
                // 説明更新
                document.getElementById('frequencyExplanation').textContent = 
                    '円形の低周波画像は、滑らかなグラデーションを持ち、周波数空間では中心付近に同心円状の分布になります。';
            }
            
            // フーリエ変換結果を描画
            drawLowFreqFourier();
            
            // 合成画像を更新
            updateImage();
        }
        
        // 高周波画像の生成
        function generateHighFreq(type) {
            currentHighFreqType = type;
            
            const width = highFreqCanvas.width;
            const height = highFreqCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // キャンバスをクリア
            highFreqCtx.clearRect(0, 0, width, height);
            highFreqCtx.fillStyle = 'white';
            highFreqCtx.fillRect(0, 0, width, height);
            
            // 画像データの作成
            const imageData = highFreqCtx.createImageData(width, height);
            const data = imageData.data;
            
            if (type === 'edges') {
                // 高周波の2次元sin波 (水平方向)
                const frequency = 20; // 周波数（高いほど波の数が増える）
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // sin波の計算
                        const value = Math.sin(x * frequency * Math.PI / width);
                        
                        // [-1, 1]の範囲から[0, 255]の範囲に変換
                        const intensity = Math.floor((value + 1) * 127.5);
                        
                        const index = (y * width + x) * 4;
                        data[index] = intensity;     // R
                        data[index + 1] = intensity; // G
                        data[index + 2] = intensity; // B
                        data[index + 3] = 255;       // A
                    }
                }
                
                // 説明更新
                document.getElementById('frequencyExplanation').textContent = 
                    '水平方向の高周波sin波は、周波数空間では中心から左右に離れた位置に強いピークとして現れます。';
            } else if (type === 'texture') {
                // 高周波の2次元sin波 (垂直方向)
                const frequency = 20; // 周波数
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // sin波の計算
                        const value = Math.sin(y * frequency * Math.PI / height);
                        
                        // [-1, 1]の範囲から[0, 255]の範囲に変換
                        const intensity = Math.floor((value + 1) * 127.5);
                        
                        const index = (y * width + x) * 4;
                        data[index] = intensity;     // R
                        data[index + 1] = intensity; // G
                        data[index + 2] = intensity; // B
                        data[index + 3] = 255;       // A
                    }
                }
                
                // 説明更新
                document.getElementById('frequencyExplanation').textContent = 
                    '垂直方向の高周波sin波は、周波数空間では中心から上下に離れた位置に強いピークとして現れます。';
            } else if (type === 'grid') {
                // 高周波の2次元sin波 (格子状)
                const frequency = 15; // 周波数
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // 水平と垂直両方向のsin波を組み合わせる
                        const valueX = Math.sin(x * frequency * Math.PI / width);
                        const valueY = Math.sin(y * frequency * Math.PI / height);
                        const value = (valueX + valueY) / 2; // 平均を取る
                        
                        // [-1, 1]の範囲から[0, 255]の範囲に変換
                        const intensity = Math.floor((value + 1) * 127.5);
                        
                        const index = (y * width + x) * 4;
                        data[index] = intensity;     // R
                        data[index + 1] = intensity; // G
                        data[index + 2] = intensity; // B
                        data[index + 3] = 255;       // A
                    }
                }
                
                // 説明更新
                document.getElementById('frequencyExplanation').textContent = 
                    '格子状の高周波sin波は、周波数空間では上下左右に離れた位置に強いピークとして現れます。';
            }
            
            // 画像データの描画
            highFreqCtx.putImageData(imageData, 0, 0);
            
            // フーリエ変換結果を描画
            drawHighFreqFourier();
            
            // 合成画像を更新
            updateImage();
        }
        
        // 低周波画像のフーリエ変換結果の描画
        function drawLowFreqFourier() {
            const width = lowFreqFourier.width;
            const height = lowFreqFourier.height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // キャンバスをクリア
            lowFreqFourierCtx.clearRect(0, 0, width, height);
            lowFreqFourierCtx.fillStyle = 'black';
            lowFreqFourierCtx.fillRect(0, 0, width, height);
            
            // 中心に強いピーク
            lowFreqFourierCtx.beginPath();
            lowFreqFourierCtx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            lowFreqFourierCtx.fillStyle = 'white';
            lowFreqFourierCtx.fill();
            
            // 中心付近のぼんやりとした光
            const gradient = lowFreqFourierCtx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, width / 6
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            lowFreqFourierCtx.fillStyle = gradient;
            lowFreqFourierCtx.beginPath();
            lowFreqFourierCtx.arc(centerX, centerY, width / 6, 0, Math.PI * 2);
            lowFreqFourierCtx.fill();
        }
        
        // 高周波画像のフーリエ変換結果の描画
        function drawHighFreqFourier() {
            const width = highFreqFourier.width;
            const height = highFreqFourier.height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // キャンバスをクリア
            highFreqFourierCtx.clearRect(0, 0, width, height);
            highFreqFourierCtx.fillStyle = 'black';
            highFreqFourierCtx.fillRect(0, 0, width, height);
            
            // 中心点（DC成分）
            highFreqFourierCtx.beginPath();
            highFreqFourierCtx.arc(centerX, centerY, 3, 0, Math.PI * 2);
            highFreqFourierCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            highFreqFourierCtx.fill();
            
            if (currentHighFreqType === 'edges') {
                // 水平方向の高周波成分は左右に現れる
                const peakDistance = width / 4; // 中心からのピークの距離
                
                // 左側のピーク
                highFreqFourierCtx.beginPath();
                highFreqFourierCtx.arc(centerX - peakDistance, centerY, 5, 0, Math.PI * 2);
                highFreqFourierCtx.fillStyle = 'white';
                highFreqFourierCtx.fill();
                
                // 右側のピーク
                highFreqFourierCtx.beginPath();
                highFreqFourierCtx.arc(centerX + peakDistance, centerY, 5, 0, Math.PI * 2);
                highFreqFourierCtx.fillStyle = 'white';
                highFreqFourierCtx.fill();
                
                // 左右のピークの周りをぼかす
                const leftGradient = highFreqFourierCtx.createRadialGradient(
                    centerX - peakDistance, centerY, 0,
                    centerX - peakDistance, centerY, 15
                );
                leftGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                leftGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                highFreqFourierCtx.fillStyle = leftGradient;
                highFreqFourierCtx.beginPath();
                highFreqFourierCtx.arc(centerX - peakDistance, centerY, 15, 0, Math.PI * 2);
                highFreqFourierCtx.fill();
                
                const rightGradient = highFreqFourierCtx.createRadialGradient(
                    centerX + peakDistance, centerY, 0,
                    centerX + peakDistance, centerY, 15
                );
                rightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                rightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                highFreqFourierCtx.fillStyle = rightGradient;
                highFreqFourierCtx.beginPath();
                highFreqFourierCtx.arc(centerX + peakDistance, centerY, 15, 0, Math.PI * 2);
                highFreqFourierCtx.fill();
                
            } else if (currentHighFreqType === 'texture') {
                // 垂直方向の高周波成分は上下に現れる
                const peakDistance = height / 4; // 中心からのピークの距離
                
                // 上側のピーク
                highFreqFourierCtx.beginPath();
                highFreqFourierCtx.arc(centerX, centerY - peakDistance, 5, 0, Math.PI * 2);
                highFreqFourierCtx.fillStyle = 'white';
                highFreqFourierCtx.fill();
                
                // 下側のピーク
                highFreqFourierCtx.beginPath();
                highFreqFourierCtx.arc(centerX, centerY + peakDistance, 5, 0, Math.PI * 2);
                highFreqFourierCtx.fillStyle = 'white';
                highFreqFourierCtx.fill();
                
                // 上下のピークの周りをぼかす
                const topGradient = highFreqFourierCtx.createRadialGradient(
                    centerX, centerY - peakDistance, 0,
                    centerX, centerY - peakDistance, 15
                );
                topGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                topGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                highFreqFourierCtx.fillStyle = topGradient;
                highFreqFourierCtx.beginPath();
                highFreqFourierCtx.arc(centerX, centerY - peakDistance, 15, 0, Math.PI * 2);
                highFreqFourierCtx.fill();
                
                const bottomGradient = highFreqFourierCtx.createRadialGradient(
                    centerX, centerY + peakDistance, 0,
                    centerX, centerY + peakDistance, 15
                );
                bottomGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                bottomGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                highFreqFourierCtx.fillStyle = bottomGradient;
                highFreqFourierCtx.beginPath();
                highFreqFourierCtx.arc(centerX, centerY + peakDistance, 15, 0, Math.PI * 2);
                highFreqFourierCtx.fill();
                
            } else if (currentHighFreqType === 'grid') {
                // 格子状パターンは上下左右に現れる
                const peakDistance = width / 4; // 中心からのピークの距離
                
                // 四隅にピークを配置
                for (let dx = -1; dx <= 1; dx += 2) {
                    for (let dy = -1; dy <= 1; dy += 2) {
                        highFreqFourierCtx.beginPath();
                        highFreqFourierCtx.arc(
                            centerX + dx * peakDistance, 
                            centerY + dy * peakDistance, 
                            5, 0, Math.PI * 2
                        );
                        highFreqFourierCtx.fillStyle = 'white';
                        highFreqFourierCtx.fill();
                        
                        // ピークの周りをぼかす
                        const gradient = highFreqFourierCtx.createRadialGradient(
                            centerX + dx * peakDistance, centerY + dy * peakDistance, 0,
                            centerX + dx * peakDistance, centerY + dy * peakDistance, 15
                        );
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        highFreqFourierCtx.fillStyle = gradient;
                        highFreqFourierCtx.beginPath();
                        highFreqFourierCtx.arc(
                            centerX + dx * peakDistance, 
                            centerY + dy * peakDistance, 
                            15, 0, Math.PI * 2
                        );
                        highFreqFourierCtx.fill();
                    }
                }
            }
        }
        
        // 合成画像の更新
        function updateImage() {
            const width = combinedCanvas.width;
            const height = combinedCanvas.height;
            
            // スライダーの値を取得
            const lowFreqWeight = parseInt(document.getElementById('lowFreqWeight').value) / 100;
            const highFreqWeight = parseInt(document.getElementById('highFreqWeight').value) / 100;
            const noiseLevel = parseInt(document.getElementById('noiseLevel').value) / 100;
            
            // 低周波画像と高周波画像を取得
            const lowFreqData = lowFreqCtx.getImageData(0, 0, width, height);
            const highFreqData = highFreqCtx.getImageData(0, 0, width, height);
            
            // 合成画像の作成
            const combinedData = combinedCtx.createImageData(width, height);
            
            for (let i = 0; i < combinedData.data.length; i += 4) {
                // 低周波と高周波の重み付き平均
                const lowValue = lowFreqData.data[i] * lowFreqWeight;
                const highValue = highFreqData.data[i] * highFreqWeight;
                
                // ノイズの追加
                const noise = noiseLevel > 0 ? (Math.random() * 2 - 1) * noiseLevel * 255 : 0;
                
                // 最終的な値の計算
                let value = lowValue + highValue + noise;
                value = Math.max(0, Math.min(255, value)); // 0-255の範囲に収める
                
                combinedData.data[i] = value;     // R
                combinedData.data[i + 1] = value; // G
                combinedData.data[i + 2] = value; // B
                combinedData.data[i + 3] = 255;   // A
            }
            
            // 合成画像の描画
            combinedCtx.putImageData(combinedData, 0, 0);
            
            // 合成画像のフーリエ変換結果の描画
            drawCombinedFourier();
        }
        
        // 合成画像のフーリエ変換結果の描画
        function drawCombinedFourier() {
            const width = combinedFourier.width;
            const height = combinedFourier.height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // スライダーの値を取得
            const lowFreqWeight = parseInt(document.getElementById('lowFreqWeight').value) / 100;
            const highFreqWeight = parseInt(document.getElementById('highFreqWeight').value) / 100;
            
            // キャンバスをクリア
            combinedFourierCtx.clearRect(0, 0, width, height);
            combinedFourierCtx.fillStyle = 'black';
            combinedFourierCtx.fillRect(0, 0, width, height);
            
            // 中心点（DC成分）
            combinedFourierCtx.beginPath();
            combinedFourierCtx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            combinedFourierCtx.fillStyle = 'white';
            combinedFourierCtx.fill();
            
            // 低周波成分（中心付近）
            if (lowFreqWeight > 0) {
                const lowGradient = combinedFourierCtx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, width / 6
                );
                lowGradient.addColorStop(0, `rgba(255, 255, 255, ${0.8 * lowFreqWeight})`);
                lowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                combinedFourierCtx.fillStyle = lowGradient;
                combinedFourierCtx.beginPath();
                combinedFourierCtx.arc(centerX, centerY, width / 6, 0, Math.PI * 2);
                combinedFourierCtx.fill();
            }
            
            // 高周波成分
            if (highFreqWeight > 0) {
                const peakDistance = width / 4; // 中心からのピークの距離
                
                if (currentHighFreqType === 'edges') {
                    // 水平方向の高周波成分は左右に現れる
                    
                    // 左側のピーク
                    combinedFourierCtx.beginPath();
                    combinedFourierCtx.arc(centerX - peakDistance, centerY, 5 * highFreqWeight, 0, Math.PI * 2);
                    combinedFourierCtx.fillStyle = `rgba(255, 255, 255, ${highFreqWeight})`;
                    combinedFourierCtx.fill();
                    
                    // 右側のピーク
                    combinedFourierCtx.beginPath();
                    combinedFourierCtx.arc(centerX + peakDistance, centerY, 5 * highFreqWeight, 0, Math.PI * 2);
                    combinedFourierCtx.fillStyle = `rgba(255, 255, 255, ${highFreqWeight})`;
                    combinedFourierCtx.fill();
                    
                    // 左右のピークの周りをぼかす
                    const leftGradient = combinedFourierCtx.createRadialGradient(
                        centerX - peakDistance, centerY, 0,
                        centerX - peakDistance, centerY, 15 * highFreqWeight
                    );
                    leftGradient.addColorStop(0, `rgba(255, 255, 255, ${0.6 * highFreqWeight})`);
                    leftGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    combinedFourierCtx.fillStyle = leftGradient;
                    combinedFourierCtx.beginPath();
                    combinedFourierCtx.arc(centerX - peakDistance, centerY, 15 * highFreqWeight, 0, Math.PI * 2);
                    combinedFourierCtx.fill();
                    
                    const rightGradient = combinedFourierCtx.createRadialGradient(
                        centerX + peakDistance, centerY, 0,
                        centerX + peakDistance, centerY, 15 * highFreqWeight
                    );
                    rightGradient.addColorStop(0, `rgba(255, 255, 255, ${0.6 * highFreqWeight})`);
                    rightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    combinedFourierCtx.fillStyle = rightGradient;
                    combinedFourierCtx.beginPath();
                    combinedFourierCtx.arc(centerX + peakDistance, centerY, 15 * highFreqWeight, 0, Math.PI * 2);
                    combinedFourierCtx.fill();
                    
                } else if (currentHighFreqType === 'texture') {
                    // 垂直方向の高周波成分は上下に現れる
                    
                    // 上側のピーク
                    combinedFourierCtx.beginPath();
                    combinedFourierCtx.arc(centerX, centerY - peakDistance, 5 * highFreqWeight, 0, Math.PI * 2);
                    combinedFourierCtx.fillStyle = `rgba(255, 255, 255, ${highFreqWeight})`;
                    combinedFourierCtx.fill();
                    
                    // 下側のピーク
                    combinedFourierCtx.beginPath();
                    combinedFourierCtx.arc(centerX, centerY + peakDistance, 5 * highFreqWeight, 0, Math.PI * 2);
                    combinedFourierCtx.fillStyle = `rgba(255, 255, 255, ${highFreqWeight})`;
                    combinedFourierCtx.fill();
                    
                    // 上下のピークの周りをぼかす
                    const topGradient = combinedFourierCtx.createRadialGradient(
                        centerX, centerY - peakDistance, 0,
                        centerX, centerY - peakDistance, 15 * highFreqWeight
                    );
                    topGradient.addColorStop(0, `rgba(255, 255, 255, ${0.6 * highFreqWeight})`);
                    topGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    combinedFourierCtx.fillStyle = topGradient;
                    combinedFourierCtx.beginPath();
                    combinedFourierCtx.arc(centerX, centerY - peakDistance, 15 * highFreqWeight, 0, Math.PI * 2);
                    combinedFourierCtx.fill();
                    
                    const bottomGradient = combinedFourierCtx.createRadialGradient(
                        centerX, centerY + peakDistance, 0,
                        centerX, centerY + peakDistance, 15 * highFreqWeight
                    );
                    bottomGradient.addColorStop(0, `rgba(255, 255, 255, ${0.6 * highFreqWeight})`);
                    bottomGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    combinedFourierCtx.fillStyle = bottomGradient;
                    combinedFourierCtx.beginPath();
                    combinedFourierCtx.arc(centerX, centerY + peakDistance, 15 * highFreqWeight, 0, Math.PI * 2);
                    combinedFourierCtx.fill();
                    
                } else if (currentHighFreqType === 'grid') {
                    // 格子状パターンは上下左右に現れる
                    
                    // 四隅にピークを配置
                    for (let dx = -1; dx <= 1; dx += 2) {
                        for (let dy = -1; dy <= 1; dy += 2) {
                            combinedFourierCtx.beginPath();
                            combinedFourierCtx.arc(
                                centerX + dx * peakDistance, 
                                centerY + dy * peakDistance, 
                                5 * highFreqWeight, 0, Math.PI * 2
                            );
                            combinedFourierCtx.fillStyle = `rgba(255, 255, 255, ${highFreqWeight})`;
                            combinedFourierCtx.fill();
                            
                            // ピークの周りをぼかす
                            const gradient = combinedFourierCtx.createRadialGradient(
                                centerX + dx * peakDistance, centerY + dy * peakDistance, 0,
                                centerX + dx * peakDistance, centerY + dy * peakDistance, 15 * highFreqWeight
                            );
                            gradient.addColorStop(0, `rgba(255, 255, 255, ${0.6 * highFreqWeight})`);
                            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                            
                            combinedFourierCtx.fillStyle = gradient;
                            combinedFourierCtx.beginPath();
                            combinedFourierCtx.arc(
                                centerX + dx * peakDistance, 
                                centerY + dy * peakDistance, 
                                15 * highFreqWeight, 0, Math.PI * 2
                            );
                            combinedFourierCtx.fill();
                        }
                    }
                }
            }
        }
        
        // 初期表示
        window.onload = function() {
            // 初期の低周波画像を生成
            generateLowFreq('gaussian');
            
            // 初期の高周波画像を生成
            generateHighFreq('edges');
            
            // 初期の合成画像を作成
            updateImage();
        };
    </script>
</body>
</html>