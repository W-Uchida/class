<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>周波数スペクトルデモ (PRF調整対応)</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background-color: #f8f9fa; color: #343a40; line-height: 1.6; }
        .container { background-color: #ffffff; padding: 25px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); max-width: 900px; margin: auto; }
        h1, h2, h3 { color: #00509e; border-bottom: 2px solid #dee2e6; padding-bottom: 5px; margin-top: 1.5em; }
        h1 { margin-top: 0; }
        .controls, .pulse-width-controls, .frequency-controls, .prf-controls { margin-bottom: 25px; padding: 15px; background-color: #e9ecef; border-radius: 5px; }
        .controls label, .pulse-width-controls label, .frequency-controls label, .prf-controls label { margin-right: 10px; cursor: pointer; font-weight: 500; }
        .controls input[type="radio"], .pulse-width-controls input[type="range"], .frequency-controls input[type="range"], .prf-controls input[type="range"] { margin-right: 5px; vertical-align: middle; }
        .pulse-width-controls, .prf-controls { display: none; }
        #pulseCyclesValueDisplay, #frequencyValueDisplay, #prfValueDisplay { font-weight: bold; color: #00509e; }
        canvas { border: 1px solid #ced4da; margin-top: 10px; background-color: #fff; display: block; margin-left: auto; margin-right: auto; }
        .chart-container { margin-bottom: 30px; text-align: center; }
        .description { margin-bottom: 25px; padding: 15px; background-color: #f1f3f5; border-left: 4px solid #007bff; border-radius: 4px; }
        .description strong { color: #00509e; }
        .formula { font-family: "Consolas", "Courier New", Courier, monospace; background-color: #e0e0e0; padding: 3px 7px; border-radius: 4px; font-size: 0.9em; border: 1px solid #ccc; display: inline-block; margin: 2px 0; }
        .footer { margin-top: 40px; text-align: center; font-size: 0.85em; color: #6c757d; }
        .java-info { text-align: center; font-style: italic; color: #495057; margin-bottom: 20px; padding: 10px; background-color: #cfe2ff; border: 1px solid #9ec5fe; border-radius: 4px; }
        .prf-info { padding: 10px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; margin-top: 10px; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>周波数スペクトル デモツール (PRF調整対応)</h1>
        <div class="java-info">このHTMLファイルはJavaプログラムによって生成されました。</div>
        <p>連続波またはパルス波の中心周波数、パルス波のパルス幅（サイクル数）、およびパルス繰り返し周波数（PRF）を調整し、時間領域波形と周波数スペクトルへの影響を視覚化します。パルス波では離散的な櫛状（comb）スペクトルが現れることが観察できます。</p>
        <div class="description">
            <h2>超音波パルスの基本パラメータ解説</h2>
            <p>
                <strong>パルス繰り返し周波数（PRF）</strong>：
                1秒間にパルスを送信する回数。 <span class="formula">PRF = 1 / T<sub>PRF</sub></span>. PRFが高いと時間分解能向上、最大深度は浅く。<span class="formula">D<sub>max</sub> &le; c / (2 &middot; PRF)</span>.
            </p>
            <p>
                <strong>パルス幅 (<span class="formula">&tau;</span>) / パルス長 (SPL)</strong>：
                1パルスの時間長/空間長。<span class="formula">&tau; = n / f<sub>0</sub></span>, <span class="formula">SPL = n &middot; &lambda;<sub>0</sub></span>. 短いほど距離分解能(<span class="formula">R<sub>ax</sub></span>)向上。<span class="formula">R<sub>ax</sub> &approx; SPL / 2</span>. (f<sub>0</sub>: 中心周波数)
            </p>
            <p>
                <strong>デューティサイクル</strong>：
                <span class="formula">DC = &tau; &middot; PRF</span>. パルス幅とPRFの積で、送信時間の割合を表す。パルス波の形状を保つため40%以下に制限。
            </p>
        </div>
        <div class="controls">
            <h3>波形の選択:</h3>
            <label><input type="radio" name="waveType" value="continuous" checked> 連続波</label>
            <label><input type="radio" name="waveType" value="pulse_preset_long"> パルス波 (プリセット長)</label>
            <label><input type="radio" name="waveType" value="pulse_preset_short"> パルス波 (プリセット短)</label>
            <label><input type="radio" name="waveType" value="pulse_custom"> パルス波 (カスタム)</label>
        </div>

        <div class="frequency-controls">
            <label for="frequencySlider">中心周波数 (Hz): </label>
            <input type="range" id="frequencySlider" min="10" max="50" value="30">
            <span id="frequencyValueDisplay">30</span> Hz
        </div>

        <div class="pulse-width-controls" id="pulseWidthControlsContainer">
            <label for="pulseCyclesSlider">パルス幅 (中心周波数のサイクル数): </label>
            <input type="range" id="pulseCyclesSlider" min="2" max="10" value="3">
            <span id="pulseCyclesValueDisplay">3</span> サイクル
        </div>

        <div class="prf-controls" id="prfControlsContainer">
            <label for="prfSlider">パルス繰り返し周波数 (Hz): </label>
            <input type="range" id="prfSlider" min="2" max="30" value="5">
            <span id="prfValueDisplay">5</span> Hz
            <div class="prf-info">
                <strong>現在の設定:</strong>
                <br>• パルス繰り返し周期: <span id="prfPeriodDisplay">0.1</span> s
                <br>• パルス幅: <span id="pulseWidthDisplay">0.15</span> s (中心周波数の<span id="pulseCyclesValueDisplay2">3</span>サイクル分)
                <br>• デューティサイクル: <span id="dutyCycleDisplay">15</span> %
                <div style="margin-top: 5px; font-size: 11px; color: #666;">
                    ※ パルス波の形状を保つため、デューティサイクルは40%以下に制限されます
                </div>
            </div>
        </div>

        <div class="chart-container">
            <h3>時間領域波形</h3>
            <canvas id="timeDomainCanvas" width="700" height="250"></canvas>
        </div>
        <div class="chart-container">
            <h3>周波数スペクトル</h3>
            <canvas id="frequencySpectrumCanvas" width="700" height="250"></canvas>
            <div style="margin-top: 10px; font-size: 12px; color: #666;">
                <span style="color: red;">■</span> 連続波スペクトル　
                <span style="color: blue;">■</span> パルス波離散スペクトル線（中心周波数±n×PRF）　
                <span style="color: green;">■</span> ベースバンドスペクトル線（n×PRF）<br>
                <span style="color: rgba(255,0,0,0.5);">---</span> sinc関数包絡線（参考）
            </div>
        </div>
    </div>
    <div class="footer">
        このデモは <a href="https://www.medical.canon/jp/lecture/lecture/lec_032.html" target="_blank" rel="noopener noreferrer">Canon Medical Systems - 超音波の基礎 第32回</a> の内容を参考に作成されました。
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const timeCanvas = document.getElementById('timeDomainCanvas');
            const freqCanvas = document.getElementById('frequencySpectrumCanvas');
            const timeCtx = timeCanvas.getContext('2d');
            const freqCtx = freqCanvas.getContext('2d');
            const waveTypeRadios = document.querySelectorAll('input[name="waveType"]');
            const pulseWidthControlsContainer = document.getElementById('pulseWidthControlsContainer');
            const prfControlsContainer = document.getElementById('prfControlsContainer');
            const pulseCyclesSlider = document.getElementById('pulseCyclesSlider');
            const pulseCyclesValueDisplay = document.getElementById('pulseCyclesValueDisplay');
            const frequencySlider = document.getElementById('frequencySlider');
            const frequencyValueDisplay = document.getElementById('frequencyValueDisplay');
            const prfSlider = document.getElementById('prfSlider');
            const prfValueDisplay = document.getElementById('prfValueDisplay');
            const prfPeriodDisplay = document.getElementById('prfPeriodDisplay');
            const pulseWidthDisplay = document.getElementById('pulseWidthDisplay');
            const dutyCycleDisplay = document.getElementById('dutyCycleDisplay');
            const pulseCyclesValueDisplay2 = document.getElementById('pulseCyclesValueDisplay2');

            const CANVAS_WIDTH = 700; const CANVAS_HEIGHT = 250; const MARGIN = 40;
            const PLOT_WIDTH = CANVAS_WIDTH - 2 * MARGIN; const PLOT_HEIGHT = CANVAS_HEIGHT - 2 * MARGIN;
            const TIME_DURATION = 2.0; /* 時間軸を長くしてPRFの効果をより見やすく */ 
            const AMPLITUDE_TIME = PLOT_HEIGHT * 0.4; const NUM_SAMPLES_TIME = 1024;
            const FREQ_MAX_DISPLAY = 200; /* スペクトル表示最大周波数 */ 
            const NUM_SAMPLES_FREQ = 512;

            let currentFrequency = 30; // Hz, 初期値を調整
            let currentPRF = 5; // Hz, 初期値を調整
            const PRESET_CYCLES_LONG = 15; const PRESET_CYCLES_SHORT = 3;
            let currentPulseCycles = PRESET_CYCLES_SHORT;

            function updateFrequency(freq) {
                currentFrequency = parseFloat(freq);
                frequencySlider.value = currentFrequency;
                frequencyValueDisplay.textContent = currentFrequency.toFixed(0);
                
                // 周波数変更時にPRFの上限を再計算
                updatePRFLimits();
                updatePRFInfo();
            }

            function updatePulseCycles(cycles) {
                currentPulseCycles = parseInt(cycles, 10);
                pulseCyclesSlider.value = currentPulseCycles;
                pulseCyclesValueDisplay.textContent = currentPulseCycles;
                if (pulseCyclesValueDisplay2) {
                    pulseCyclesValueDisplay2.textContent = currentPulseCycles;
                }
                
                // パルス幅変更時にPRFの上限を再計算
                updatePRFLimits();
                updatePRFInfo();
            }

            function updatePRF(prf) {
                currentPRF = parseFloat(prf);
                prfSlider.value = currentPRF;
                prfValueDisplay.textContent = currentPRF.toFixed(0);
                updatePRFInfo();
            }

            function updatePRFLimits() {
                if (currentFrequency > 0) {
                    const pulseWidthInTime = currentPulseCycles / currentFrequency;
                    // パルス間に最低でもパルス幅の1.5倍の間隔を確保（デューティサイクル < 40%）
                    const maxSafePRF = Math.floor(1 / (2.5 * pulseWidthInTime));
                    const actualMaxPRF = Math.max(2, Math.min(30, maxSafePRF));
                    
                    prfSlider.max = actualMaxPRF;
                    
                    // 現在のPRFが上限を超えている場合は調整
                    if (currentPRF > actualMaxPRF) {
                        currentPRF = actualMaxPRF;
                        updatePRF(currentPRF);
                    }
                    
                    // PRFスライダーの表示更新
                    const prfLabel = document.querySelector('label[for="prfSlider"]');
                    if (prfLabel) {
                        prfLabel.textContent = `パルス繰り返し周波数 (2-${actualMaxPRF} Hz): `;
                    }
                }
            }

            function updatePRFInfo() {
                const prfPeriod = 1 / currentPRF;
                const pulseWidth = currentPulseCycles / currentFrequency;
                const dutyCycle = Math.min(100, (pulseWidth * currentPRF * 100));
                
                prfPeriodDisplay.textContent = prfPeriod.toFixed(3);
                pulseWidthDisplay.textContent = pulseWidth.toFixed(4);
                dutyCycleDisplay.textContent = dutyCycle.toFixed(1);
                
                // デューティサイクルが高すぎる場合の警告表示
                const prfInfo = document.querySelector('.prf-info');
                if (dutyCycle > 35) {
                    prfInfo.style.backgroundColor = '#ffe6e6';
                    prfInfo.style.borderColor = '#ffb3b3';
                } else {
                    prfInfo.style.backgroundColor = '#fff9c4';
                    prfInfo.style.borderColor = '#ffeaa7';
                }
            }

            function clearCanvas(ctx) { ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); }
            function drawAxes(ctx, xLabel, yLabel, xMax, yMaxText = "振幅") { 
                ctx.beginPath(); ctx.strokeStyle = '#333'; ctx.lineWidth = 1; 
                ctx.moveTo(MARGIN, MARGIN / 2); ctx.lineTo(MARGIN, CANVAS_HEIGHT - MARGIN); 
                ctx.moveTo(MARGIN, CANVAS_HEIGHT - MARGIN); ctx.lineTo(CANVAS_WIDTH - MARGIN / 2, CANVAS_HEIGHT - MARGIN); 
                ctx.stroke(); ctx.fillStyle = '#333'; ctx.textAlign = 'center'; 
                ctx.fillText(xLabel, CANVAS_WIDTH / 2, CANVAS_HEIGHT - MARGIN / 4 + 5); 
                ctx.save(); ctx.translate(MARGIN / 3 - 5, CANVAS_HEIGHT / 2); ctx.rotate(-Math.PI / 2); 
                ctx.fillText(yLabel, 0, 0); ctx.restore(); ctx.textAlign = 'right'; 
                ctx.fillText(xMax.toString(), CANVAS_WIDTH - MARGIN / 2, CANVAS_HEIGHT - MARGIN + 15); 
                ctx.textAlign = 'left'; ctx.fillText(yMaxText, MARGIN + 5, MARGIN / 2 + 5); 
            }

            function drawTimeWaveform(type) {
                clearCanvas(timeCtx);
                drawAxes(timeCtx, "時間 (s)", "振幅", TIME_DURATION.toFixed(2));
                timeCtx.beginPath(); timeCtx.strokeStyle = 'blue'; timeCtx.lineWidth = 1.5;
                const dt = TIME_DURATION / NUM_SAMPLES_TIME;
                const y_center = MARGIN + PLOT_HEIGHT / 2;

                for (let i = 0; i <= NUM_SAMPLES_TIME; i++) {
                    const t = i * dt;
                    const x_canvas = MARGIN + (t / TIME_DURATION) * PLOT_WIDTH;
                    let y_val = 0;
                    if (type === 'continuous') {
                        y_val = Math.sin(2 * Math.PI * currentFrequency * t);
                    } else if (type.startsWith('pulse')) {
                        const pulseCarrierFreq = currentFrequency;
                        if (pulseCarrierFreq === 0) { 
                            y_val = 0; 
                        } else {
                           const pulseWidthInTime = currentPulseCycles / pulseCarrierFreq;
                           const PULSE_REP_PERIOD = 1 / currentPRF; // PRFから繰り返し周期を計算
                           const t_in_pulse_envelope = t % PULSE_REP_PERIOD;
                           
                           if (t_in_pulse_envelope < pulseWidthInTime && pulseWidthInTime > 0) {
                               // ハニング窓を適用
                               const hanning_window = 0.5 * (1 - Math.cos(2 * Math.PI * t_in_pulse_envelope / pulseWidthInTime));
                               const carrier_wave = Math.sin(2 * Math.PI * pulseCarrierFreq * t_in_pulse_envelope);
                               y_val = carrier_wave * hanning_window;
                           } else {
                               y_val = 0;
                           }
                        }
                    }
                    const y_canvas = y_center - y_val * AMPLITUDE_TIME;
                    if (i === 0) timeCtx.moveTo(x_canvas, y_canvas); else timeCtx.lineTo(x_canvas, y_canvas);
                }
                timeCtx.stroke();
            }

            function drawFrequencySpectrum(type) {
                clearCanvas(freqCtx);
                drawAxes(freqCtx, "周波数 (Hz)", "強度", FREQ_MAX_DISPLAY, "強度");
                const y_base = CANVAS_HEIGHT - MARGIN;
                const displayFreq = currentFrequency;

                if (type === 'continuous') {
                    // 連続波：中心周波数にデルタ関数
                    if (displayFreq >= 0 && displayFreq <= FREQ_MAX_DISPLAY) {
                        freqCtx.beginPath();
                        freqCtx.strokeStyle = 'red';
                        freqCtx.lineWidth = 3;
                        const freq_canvas_x = MARGIN + (displayFreq / FREQ_MAX_DISPLAY) * PLOT_WIDTH;
                        freqCtx.moveTo(freq_canvas_x, y_base);
                        freqCtx.lineTo(freq_canvas_x, MARGIN);
                        freqCtx.stroke();
                    }
                } else if (type.startsWith('pulse')) {
                    const centerFreq = displayFreq;
                    if (centerFreq > 0) {
                        const pulseWidthInTime = currentPulseCycles / centerFreq;
                        
                        // パルス波のスペクトル：PRF間隔で並んだ離散スペクトル線
                        // 各スペクトル線の振幅はsinc関数で変調される
                        
                        freqCtx.strokeStyle = 'blue';
                        freqCtx.lineWidth = 2;
                        
                        // 中心周波数周辺のPRF間隔スペクトル線
                        const maxLines = Math.floor(FREQ_MAX_DISPLAY / currentPRF);
                        
                        for (let n = -maxLines; n <= maxLines; n++) {
                            const spectral_freq = centerFreq + n * currentPRF;
                            
                            if (spectral_freq >= 0 && spectral_freq <= FREQ_MAX_DISPLAY) {
                                // sinc関数による振幅変調
                                // sinc(π * n * PRF * τ) where τ = pulse width
                                let sinc_arg = Math.PI * n * currentPRF * pulseWidthInTime;
                                let sinc_value = (Math.abs(sinc_arg) < 1e-8) ? 1.0 : Math.sin(sinc_arg) / sinc_arg;
                                let amplitude = Math.abs(sinc_value);
                                
                                const x_spectral = MARGIN + (spectral_freq / FREQ_MAX_DISPLAY) * PLOT_WIDTH;
                                const y_spectral = y_base - amplitude * PLOT_HEIGHT * 0.8;
                                
                                freqCtx.beginPath();
                                freqCtx.moveTo(x_spectral, y_base);
                                freqCtx.lineTo(x_spectral, y_spectral);
                                freqCtx.stroke();
                                
                                // スペクトル線の上に周波数値を表示（主要なもののみ）
                                if (amplitude > 0.1 && spectral_freq <= FREQ_MAX_DISPLAY * 0.9) {
                                    freqCtx.fillStyle = 'blue';
                                    freqCtx.font = '10px Arial';
                                    freqCtx.textAlign = 'center';
                                    freqCtx.fillText(spectral_freq.toFixed(0), x_spectral, y_spectral - 5);
                                }
                            }
                        }
                        
                        // ベースバンド成分（DC周辺のPRF間隔スペクトル線）
                        freqCtx.strokeStyle = 'green';
                        freqCtx.lineWidth = 2;
                        
                        for (let n = 0; n <= Math.floor(FREQ_MAX_DISPLAY / currentPRF); n++) {
                            const baseband_freq = n * currentPRF;
                            
                            if (baseband_freq <= FREQ_MAX_DISPLAY && baseband_freq < centerFreq - 2*currentPRF) {
                                // ベースバンドでのsinc関数
                                let sinc_arg = Math.PI * n * currentPRF * pulseWidthInTime;
                                let sinc_value = (Math.abs(sinc_arg) < 1e-8) ? 1.0 : Math.sin(sinc_arg) / sinc_arg;
                                let amplitude = Math.abs(sinc_value) * 0.3; // ベースバンドは振幅小
                                
                                const x_baseband = MARGIN + (baseband_freq / FREQ_MAX_DISPLAY) * PLOT_WIDTH;
                                const y_baseband = y_base - amplitude * PLOT_HEIGHT * 0.8;
                                
                                freqCtx.beginPath();
                                freqCtx.moveTo(x_baseband, y_base);
                                freqCtx.lineTo(x_baseband, y_baseband);
                                freqCtx.stroke();
                                
                                // ベースバンド周波数値表示
                                if (amplitude > 0.05) {
                                    freqCtx.fillStyle = 'green';
                                    freqCtx.font = '10px Arial';
                                    freqCtx.textAlign = 'center';
                                    freqCtx.fillText(baseband_freq.toFixed(0), x_baseband, y_baseband - 5);
                                }
                            }
                        }
                        
                        // sinc関数の包絡線を点線で参考表示
                        freqCtx.setLineDash([3, 3]);
                        freqCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                        freqCtx.lineWidth = 1;
                        freqCtx.beginPath();
                        
                        const df = FREQ_MAX_DISPLAY / 200; // 細かい間隔で包絡線を描画
                        for (let i = 0; i <= 200; i++) {
                            const f_env = i * df;
                            const x_env = MARGIN + (f_env / FREQ_MAX_DISPLAY) * PLOT_WIDTH;
                            
                            // 中心周波数を中心としたsinc関数包絡線
                            let sinc_arg = (f_env - centerFreq) * pulseWidthInTime;
                            let sinc_value = (Math.abs(sinc_arg) < 1e-8) ? 1.0 : Math.sin(Math.PI * sinc_arg) / (Math.PI * sinc_arg);
                            let amplitude = Math.abs(sinc_value);
                            
                            const y_env = y_base - amplitude * PLOT_HEIGHT * 0.8;
                            if (i === 0) freqCtx.moveTo(x_env, y_env);
                            else freqCtx.lineTo(x_env, y_env);
                        }
                        freqCtx.stroke();
                        freqCtx.setLineDash([]);
                    }
                }
            }

            function updateDisplay() {
                const selectedType = document.querySelector('input[name="waveType"]:checked').value;
                if (selectedType.startsWith('pulse')) {
                    pulseWidthControlsContainer.style.display = 'block';
                    prfControlsContainer.style.display = 'block';
                    if (selectedType === 'pulse_preset_long') updatePulseCycles(PRESET_CYCLES_LONG);
                    else if (selectedType === 'pulse_preset_short') updatePulseCycles(PRESET_CYCLES_SHORT);
                } else {
                    pulseWidthControlsContainer.style.display = 'none';
                    prfControlsContainer.style.display = 'none';
                }
                drawTimeWaveform(selectedType);
                drawFrequencySpectrum(selectedType);
            }

            waveTypeRadios.forEach(radio => { radio.addEventListener('change', updateDisplay); });
            pulseCyclesSlider.addEventListener('input', () => { 
                document.querySelector('input[name="waveType"][value="pulse_custom"]').checked = true; 
                updatePulseCycles(pulseCyclesSlider.value); 
                updateDisplay(); 
            });
            frequencySlider.addEventListener('input', () => { 
                updateFrequency(frequencySlider.value); 
                updateDisplay(); 
            });
            prfSlider.addEventListener('input', () => { 
                updatePRF(prfSlider.value); 
                updateDisplay(); 
            });

            // 初期表示
            updateFrequency(frequencySlider.value);
            updatePulseCycles(pulseCyclesSlider.value);
            updatePRF(prfSlider.value);
            updatePRFLimits(); // 初期制限設定
            updateDisplay();
        });
    </script>
</body>
</html>